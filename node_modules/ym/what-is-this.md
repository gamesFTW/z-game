Что это? Зачем и для кого? Как этим пользоваться?

На эти вопросы я давно хотел получить ответы, но стеснялся их задать. Спросить и прослыть тупицей? Дудки,
я лучше помолчу. Если вы такой же робкий, этот документ именно для вас :)

Что это?
--------
Вы web-разработчик, пишете сайты; на страницах верстаете формочки с контролами,
различные компоненты, большие и маленькие; для большинства из них
пишете клиентский js-код? Вот и продолжайте это делать. Пока у вас нет своего кода,
модульная система вам не нужна. Никому не нужен пустой фантик без конфеты внутри.

Модуль - это фантик, в который вы заворачиваете свою конфету. На фантике написано имя конфеты и больше ничего. Вот вы
 и поняли, что такое модуль. Оберните код пяти своих контролов каждый в свой отдельный фантик,
 у вас получится 5 модулей — система из пяти **ваших** модулей. Конфеты ссыпают в корзинку для сладостей,
 откуда конфеты удобно таскать детям. Модульная система и есть такая корзинка.

 Модуль - это контейнер, внутрь которого вы помещаете код своего компонента, и захлопываете крышку. Только, в отличие
 от герметичного стального контейнера, "стенки" модуля прозрачные, невидимые. Их словно и нет. А профит есть. Много
 профита.


Зачем это и для кого?
--------------------
Как вы связываете компоненты между собой? Например, вы объявляете на странице блок с формой авторизации,
пишете для неё клиентский javascript-код, в котором описываете поведение формы: нажали на кнопку сабмита — отправь
авторизационные данные аяксом, а не через стандартный `form.submit()`.

И допустим, в проекте уже есть специальный компонент "кнопка", в котором реализовано всё поведение кнопки,
например, "если меня нажали, нужно что-то сделать, не знаю что - это решает другой компонент,
в который меня пригласят поработать".

То есть, ваша "форма" должна уметь найти кнопку, заполучить её внутрь себя, и слушать на ней событие клика.

Как вы определяете, что кнопка **уже готова** взаимодействовать с другими блоками?


Модульная система умеет это делать вместо вас. Она избавляет вас от головной боли отслеживать зависимости между
компонентами, поддерживать руками эти зависимости в актуальном состоянии. Это реализовано примерно как наследование,
 когда в коде компонента явно указано, от какого класса наследоваться. Только модульная система занимается не наследованием,
а зависимостями между компонентами. Ваш модуль говорит вслух: "для моей корректной работы нужен такой-то компонент".

Если вы оформляете форму в виде ymaps-модуля, вы просто декларируете зависимость от кнопки, и знаете,
что код формы будет активирован тогда, когда для этого всё готово, в частности, кнопка готова слушать событие
клика на себя. Вам не нужно самому отслеживать готовность ваших компонентов. Это делает за вас модульная система.


Как этим пользоваться?
---------------------
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
````

В этом примере ваш собственный код  - единственная строка:
````javascript
var a = {};
````

Всё остальное - обёртка, фантик. Именно этот фантик делает из вашего кода модуль.
Внутрь фантика (специальные js-конструкции) вы складываете нужные ингредиенты (зависимости от других
модулей), перемешиваете, как вам хочется (пишете код своего компонента), фантик скручиваете и втыкаете
в бок зубочистку-флажок с именем модуля. Вы сделали модуль "форма".

Давайте посмотрим на конфету внимательно.

Так объявляется модуль. Позовите метод `define()`
````javascript
modules.define(
);
````

Скажите модулю: "Тебя зовут `А`"
````javascript
modules.define(
    'A'
);
````

Потом добавьте: "Вообще-то ты зависишь от модулей `В` и `С`"
````javascript
modules.define(
    'A',
    ['B', 'C'],
);
````

Опишите код модуля в анонимной функции. В него параметрами придёт код модулей `B` и `С`,
и вы сможете использовать их внутри модуля.
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

    }
);
````

Чтобы другие модули могли использовать этот модуль, пусть ваш модуль громко произнесёт вслух:
"Модуль `А` - это я!". Вы делаете это методом `provide(а)`
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
````

И, наконец, напишите свой компонент. Пусть это будет что-нибудь хорошее ;)
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = 'Yandex is a good company';

        provide(a);
    }
);
````

Всё. Сложности закончились :)

А вот так, к примеру, может выглядеть код модуля, отвечающий за форму логина. Создадим фантик,
позовём в него кнопку и что-нибудь запрограммируем внутри:
````javascript
modules.define(
    'y-form',
    ['y-button'],
    function(provide, button) {
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(button).css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
````

Это выдуманный пример, он вообще нерабочий. В теле анонимной функции мы программируем поведение формы в
зависимости от того, активна или неактивна кнопка. А после этого методом `provide(form)` выбрасываем вверх флаг:
"Форма — это я". Теперь и этот модуль может быть вызван другими модулями. Метод `provide` - это выкинутая вверх рука
и всемирно известное: "Свободная касса!"

Возвращаясь к аналогии с конфетой, фантик — это метод `define()` с анонимной функцией внутри. В фантик воткнута зубочистка, за которую конфетку удобно взять — это метод `provide()`. Модуль
независим и работоспособен, потому что он будет запущен только после того, как все зависимости будут предоставлены
(правильные программисты используют термины "разрезолвлены" или "разрешены") внутрь модуля.

Осталось сказать, что зависимости резолвятся асинхронно, дерево зависимостей строится в рантайме,
модули можно переопределять и доопределять. А теперь возвращаю вас к главной странице инструмента: https://github.com/ymaps/modules

Пользуйтесь на здоровье, автор инструмента желает вам успехов и не против выпить с вами вкусного коньяку ;)

PS. Кстати, дерево зависимостей, построенное модульной системой, можно использовать в любом файловом сборщике,
потому что имя модуля легко мапится на имя файла,в котором этот модуль хранится. И тогда
вы ещё и собирать файлы руками не будете, всё будут делать роботы ;)


Багрепорты, сложные вопросы и благодарности присылайте на dfilatov@yandex-team.ru :)
